---
layout: page
title: Cryptanalysis of Symmetric Encryption Algorithms
description: 
img: 
importance: 1
category: work
related_publications: false
---

My Bachelor Thesis Project focused on applying a novel black box approach to analyze the security of two widely used symmetric encryption algorithms: RC4 and AES128. The project was conducted under the guidance of **[Dr. Virendra Sule](https://iitb.irins.org/profile/11184)** at the Department of Electrical Engineering, IIT Bombay as a part of my **Bachelor’s degree in Electrical Engineering** from **IIT Bombay**

## <b><u>Project Overview</u></b>

The research aimed to identify potential weaknesses in these encryption algorithms by studying the linear complexity (LC) patterns of sequences generated through recursive applications of the encryption functions. This approach differs from traditional cryptanalysis methods by treating the encryption algorithm as a black box and analyzing only its input-output behavior. 

We aimed to analyze ciphertexts which known key patterns and pbserve if there was a detectable pattern in the ciphertexts thus generated and find potential weak keys. We aimed to utilize a novel black box approach[^1] for cryptanalysis of the RC4 algorithm for key stream generation. We aim to determine the number of ”weak keys” and the pattern of linear complexity (LC) of the recurrences generated by the RC4 map as a function of the seed and find the density of low LC recurrences. We also aimed to actually compute the seed from the recurrence sequence generated by the map of RC4 for the cases with smaller number of bits in the key.




## <b><u>Why were RC4 and AES128 chosen?</u></b>
The RC4 algorithm has been studied since along time and it has been reported that the output stream of the algorithm is statistically biased[^2]. Hence RC4 is considered as a weak algorithm. However to this date no methodology seems to have been proposed to either determine the symmetric key (the initial random seed) input to the algorithm or to estimate the computational efforts to recover the key.

As for AES, AES128 is a symmetric block cipher that uses a 128-bit key and operates on 128-bit blocks of plaintext. It has a large key space which is the total number of possible keys that can be used to encrypt and decrypt data, and for AES128, it is $$2^{128}$$. This means that an attacker would need to try an astronomical number of keys to break the encryption, making it computationally infeasible to do so. However to this date (2022) no methodology seems to have been proposed ( that I knew of) to either determine the symmetric key (the initial random seed) input to the algorithm or to estimate the computational efforts to recover the key.

## <u><b>RC4 Analysis</b></u> 
### <b>Sequence Generation</b>
In the first part of the project, I implemented the RC4 algorithm and analyzed its key stream generation. RC4 is a widely used stream cipher known for its simplicity and speed, but with documented statistical biases. My implementation involved:

1. Choose a random *k* bit key and repeat it until it fills a 256 byte array *K*. Then we initialize a 256 byte stream array S with $$S[i]\ =\ i$$. 
2. Using the **Key Scheduling Algorithm**(KSA), starting with S[0] to S[255], for each S[i], the algorithm swaps it with another byte in S according to a scheme dictated by K[i]. This phase of the algorithm determines the map $$KSA:F^K \rightarrow F^{256}$$. We denote this with the following equation $$S=KSA(K)$$

3. Using a **Pseudo-Random Stream Generator**(PRNG), I generate a vector *Y* as follows $$Y = F (K) = P RSG(KSA(K))$$

4. This map F is then used for generating a recursive sequence,
$$S(F,Y) = \{Y, F (Y ), F^{(2)}(Y), \cdots \}$$


### <b>LC Computation</b>
We generate a finite recurrence sequence of *F* starting from a point *y* in the image of *F* of $$O(n^3)$$ length, which we take to be $$4n^3$$, for our implementation.  

We follow the following algorithm to generate the sequence:

1. We first start with an *n*-bit key *y*. Using *F*, we calculate *F(y)*.
2. We extract the first *n* bits from *F(n)* to generate the new key.
3. Using this *n*-bit key, we generate the sequence as shown in Sequence Generation above.
4. We continue this $$4n^3$$ times to obtain our sequence, a binary sequence of *n*-bit elements.

Now, we use this obtained sequence to generate the LCs:
- The LC is defined to be the index $$k[1]$$ at which the rank of the Hankel matrix $$H(k)$$   defined by the sequence is maximum.
- Compute the minimal polynomial coefficient vector by solving the equation  $$H(k) \hat{\alpha} = h(k + 1)$$ and solve for the local inverse in the periodic orbit of *y*.
- We verify whether the computed *x* satisfies $$y = F(x)$$ to eliminate false positives.


The computation of this *x* and the verification is defined in detail in [^1].

#### <u>Local Inverse Calculation</u>

When the key length is small, we can calculate the local inverse. For a length of less than 256 bytes, this mapping becomes an embedding. In this case, we can construct a map $$F_i: F^L \rightarrow F^L$$ where *L* is the key length by defining a projection $\Pi_i$ from the set $$\{1, 2, ..., 256\}$$ to a subset of *L* indices in this set and consider: $$F_i = \Pi_i ∘ KSA$$

Then for LC computation, we consider the recurrence sequence generated by the map:  

$$S_i = Π_i(S) = F_i(K) = \Pi_i ∘ KSA(K)$$

Let $m_i$ denote the LC of this map and $m_i(X)$ be the minimal polynomial of the recurrence:

$$\{S_i, F_i(S_i), F_i^2(S_i), \cdots, F_i^i(S_i)$$

where $$M_i = L^3$$. To solve the local inverse *K* at a given vector output $$S = KSA(K)$$, solve the local inverse of $$S_i = F_i(K)$$ and verify that the solution obtained is correct for all other $$F_i$$.


## <u><b>AES Analysis</b></u>

The second part extended the analysis to AES128, a more modern and secure block cipher. 

### <b>Sequence Generation</b>
We generate a finite recurrence sequence of *F* starting from a point *y* in the image of **F** of length $O(n^3)$, which we take to be $2n^3$  for our implementation since we have a 128-bit *n*.

- We first start with a 16-bit random key $$K_0$$ and replicate it to fill up a 128-bit key $$k_0$$.
- Using $$k_0$$ and $$p_0$$, we generate the ciphertext $$c_0$$.
- Using the first 16 bits of $$c_0$$, we generate $$K_1$$ and replicate it to fill a 128-bit key $$k_1$$.
- Using $$p_0$$ and $$k_1$$, we generate $$c_1$$. 

<p style="text-align: center;">$$c_{i-1} \rightarrow K_i$$ </p>

<p style="text-align: center;">$$K_i \rightarrow k_i$$ $$AES128(p_0, k_i) \rightarrow c_i$$ </p>

- We do this $$2n^2$$ times to get a sequence: $$\{ c_0, c_1, c_2 , \dots , c_{2n^2-2}, c_{2n^2-1} \}$$

### <b>Linear Complexity Computation</b>

Our goal is to use **Local Inversion** and **Black Box** techniques to use these 128-bit vector sequences of length $$2n^2$$ to recompute the "inverse" of $$c_0$$, i.e., $$p_0$$.

Now, we use this obtained sequence to generate the LCs:
- The LC is defined to be the index $$k[1]$$ at which the rank of the Hankel matrix $$H(k)$$  defined by the sequence is maximum.
- Compute the minimal polynomial coefficient vector by solving the equation  $$H(k) \hat{\alpha} = h(k + 1)$$ and solve for the local inverse in the periodic orbit of *y*.
- We verify whether the computed *x* satisfies $$y = F(x)$$ to eliminate false positives.


The computation of this *x* and the verification is defined in detail in the literature here [^1].

### Local Inverse Calculation
This was implemented in the same way as that for RC4.

## <u><b>Technical Implementation</b></u>

The project involved significant computational challenges, requiring optimization of both algorithms and data handling. I progressively improved my implementation from Python+SageMath to Python+C++ and finally to a fully C++ solution, reducing computation time from 72 hours to just minutes for certain test cases. 

I acknlowledge the contribution of the **Rudra Server Computing facility** at **IIT Bombay** in performing the more computationally intensive analyses.

### <b>RC4 Implementation</b>
The implementations were using Python, SageMath, C++ and Bash scripting being used at various stages.

#### <u>Python + SageMath</u>
This utilization used multiprocessing to parallelize the RC4 stream calculations and stored the keystreams into a single array, which was later read to calculate the ranks, allowing us to get various essential graphs of ranks vs number of bits. After obtaining the ranks, the required sequences were later processed using various SageMath modules imported into python, such as Berlekamp Massey, Sequence and Matrix amongst others.

        {% include figure.liquid loading="eager" path="assets/img/blackbox/RC4_TimeCurve_n3_vs_n2.jpg" title="Performance Comparison between $n^3$ and$n^2$" class="img-fluid rounded z-depth-1" %}

The y-axis in this figure denotes the time taken for recomputation of the keys starting from a base key, it is the time taken for the computation of sequences from a given n-bit key and then using these sequences to re-compute the key
    
The program was sequential, with no files stored on disk except for the graphs. Rank calculations of Hankel matrices over *GF(2)* were optimized using a custom function, reducing computation time to a sixth of what *SageMath's .rank()* function required. Multiprocessing was implemented with a maximum of 24 workers on a *Xeon machine* and 16 on an *i7-9750h*. However, the sequence storage method was complex, making extraction for verification impossible. The execution time was extremely high, reaching up to **72 hours** for a **4n³** sequence with a *16-bit key*. Inefficiencies arose due to redundant calculations in the *PSRG* implementation, with the bulk of the time consumption occurring post-sequence construction. These issues were addressed in *Attempt 2* by rewriting the code in *C++* for improved efficiency.

####  <u>Python + C++</u>

In this attempt, we changed the way the keys were passed onto the next stage during the calculation of sequences, making it more generous and accomodating for cases where the bit-length of the key was not a multiple of 8. The implementation in C++ was performed with the help of NTL Library[^3]. To allow for the codes written in python and C++ to work together, we decided to extract the sequences in a text file. The sequences are now stored in a single large text file which is read by the C++ By experimentation we found out that the best way was to have this text file split into multiple files and then changed to be in a format it would be easier for the NTL Library based implementation to work.

The huge text file was converted into individual files stored in the *keys* folder with the name *key_\(binary representation of key\).txt*. For example, the keyfile after conversion from the large text file for a key = 12 for a 8 bit key would be stored at *./keys/key\textunderscore00001100.txt*. The conversion of the large text file into smaller text files was done using some basic bash scripting and python. 


| Number of bits | Number of keys | Sequence length | Time for sequence computations (in s) | Time for file conversion (in s) | Time for key calculation (in s) | Total Time (in s) | Number of correct computations | Percentage of correct key calculations |
|---------------|--------------|----------------|--------------------------------|-------------------------------|-----------------------------|----------------|------------------------------|----------------------------------|
| 8             | 256          | 256            | 14.2                           | 10                            | 5                           | 2902           | 23                           | 8.98438                          |
| 16            | 65536        | 1024           | 46000                          | 1200                          | 25                          | 47225          | 198                          | 0.282288                         |



The sequences can now be extracted for individual assessment, and the overall computation time has been significantly reduced from over three days to just over **12 hours**. However, a large number of files are being written to disk after conversion, leading to inefficiencies. Additionally, time is being wasted on converting text files between formats, and sequence computations remain time-consuming. The primary bottleneck is still in sequence construction, which was addressed in Attempt 3 by rewriting the code in *C++* for further optimization.

#### <u>C++ Using NTL</u>
The first section was rewritten in C++, which directly created the keys files which the NTL-based code can directly read, this has led to a huge increase in the time saved and greatly reduced the time required for computations. The times taken for the computations for the keys of length 18bit have not been included here due to the lack of sufficient verification, the total time taken, was around **5000 seconds**. The results can be summarized to be


| Number of bits | Number of keys | Sequence length | Time for sequence computations (in s) | Time for key calculation (in s) | Total Time (in s) | Number of correct computations | Percentage of correct key calculations |
|---------------|--------------|----------------|--------------------------------|-----------------------------|----------------|------------------------------|----------------------------------|
| 8             | 256          | 256            | 0.077                          | 0.005                       | 5.656          | 23                           | 8.98438                          |
| 8             | -            | 2048           | 0.723                          | 7.35                        | 8.073          | 23                           | 8.98438                          |
| 12            | 4096         | 576            | 2.9                            | 0.134                       | 3.034          | 2                            | 0.048                            |
| 14            | 16384        | 784            | 16.95                          | 0.890                       | 17.84          | 84                           | 0.512695                          |
| 16            | 65536        | 1024           | 205                            | 25.34                        | 230.34         | 198                          | 0.282288                          |
| 16            | -            | 16384          | 866                            | 1200                        | 2066           | 198                          | 0.282288                          |



The times have been significantly reduced, eliminating the need for intermediate file conversions. Additionally, both files are now in the same language, which enhances flexibility and streamlines the process. However, a downside to this improvement is that a large number of files are being written to disk after conversion, which could potentially lead to storage and performance concerns.

### <b>AES Implementation</b>
The implementations were using  C++ and Bash scripting being used at various stages. Since AES128 is a block cipher, output of 1 block is independent of other blocks, therefore we chose plaintext size ranging from 1024 bits to $$2n^2$$ bits. The reason for a large plaintext size was to provide enough test cases for our computations. Considering that our goal was to just analyse the effects of "weakness" of the key and plaintext on the ciphertext, we utilized the Electronic Codebook (ECB) mode in AES. OpenSSL[^4] Library was used in C++ for the generation of sequences, and NTL Library[^3] in C++ was used for the computation of minimal polynomial, the Linear Complexity and the subsequent local inversion.

#### <u>Implementation 1: EVP Interface for 16bitkey</u>

- We use the EVP Interface for implementing the algorithm. *EVP_CIPHER_CTX_new()* for initializing the cipher.
- We use "special" plaintexts for our weakness, each $$p_i$$ is designed to have (i+1) 0s followed by a 1 which is followed again by *(i+1)* 0s and so on. The plaintext length chosen is $$n^2$$. Initially, we generate a random 16-bit key and replicate it to generate a 128-bit key which is used as $$k_0$$.
- During initialization, we provide an *EVP_CIPHER* object. In this case, we use *EVP_aes_128_ecb()*, which uses the AES algorithm with a 128-bit key in ECB mode.
- The encryption and plaintext generation are carried out by custom functions, the former of which utilizes EVP_* functions such as *EVP_EncryptInit_ex()*, *EVP_EncryptUpdate()* and *EVP_EncryptFinal_ex()*.
- After each round of ciphertext generation $$c_i$$, we proceed to replicate the first 16-bit of ciphertext into a new key to be used for another round of AES generation to generate a new ciphertext $$c_{i+1}$$. There are about $$2n^2$$ rounds.
- The first 128-bit of the ciphertext in binary format are stored in respective text files.

#### <u>Implementation 1b: EVP Interface for 32bitkey</u>

All conditions remain the same as in Implementation 1, but instead of choosing a 16-bit random key at the beginning, we choose a 32-bit random key to be replicated. During the generation of new $$K_i$$'s, we consider the first 32 bits of ciphertext rather than the first 16 bits.

#### <u>Implementation 2: AES_* for 16-bit key</u>

- We use the Low-level AES_* functions for implementing the algorithm.
- We use "special" plaintexts similar to the first implementation but with lower length.
- The initial random 16-bit key generation and replication is the same as in Implementation 1, but here, we pass it to *AES_set_encrypt_key()* alongside an *AES_KEY* object. This copies the 128-bit generated key into the *AES_KEY* object.
- We use *AES_encrypt()* to implement AES128 ECB encryption, block by block using the key and the ciphertext.
- The sequence generation remains the same as in Implementation 1, but the number of $c_i$s is now about $$2n^2$$.

**_Note:_** It is **_NOT_** recommended to use this implementation since it is deprecated and vulnerable to attacks such as side-channel attacks.

#### <u>Implementation 3: Roundwise AES for 16bit key</u>

We modified existing code available[^5] and modified it extensively to suit our needs.

- **AddRoundKey**: Performs a bitwise XOR operation between the state and the round key.
- **SubBytes**: Performs a substitution to each of the 16 bytes of the state using an S-box lookup table.
- **ShiftRows**: Shifts the bytes of each row in the state to the left to add diffusion.
- **MixColumns**: Mixes the columns of the state using multiplication by 2 and 3 look-up tables.
- **Round**: Performs one round of the algorithm, consisting of the *SubBytes*, *ShiftRows*, *MixColumns*, and *AddRoundKey* steps.
- **FinalRound**: Performs the final round of the algorithm, consisting of the *SubBytes*, *ShiftRows*, and *AddRoundKey* steps.
- **AESEncrypt**: Encrypts the message using the AES algorithm by performing the rounds of the algorithm on the state and the expanded key and copying the encrypted state to the *encryptedMessage* buffer.

<br>

## <u><b>Results</b></u>
### <b>RC4</b>
As seen in the graphs and tables in the Implementation section, we concluded that, while our novel black-box approach shows promise for cryptanalyzing RC4, especially for shorter key lengths, its effectiveness diminishes as key size increases. 

We were able to successfully retrieve keys for low bit-lengths, demonstrating the potential vulnerability of RC4 for shorter key sizes. Our approach significantly improved computation time across iterations, with our final C++ implementation dramatically reducing processing time.

However, we observed that the percentage of correctly calculated keys decreased as the key length increased, indicating that our method becomes less effective for longer keys. For 8-bit keys, the success rate remained consistent at about 8.98%, regardless of sequence length. The highest number of correct key computations was achieved for 16-bit keys, with 198 successful retrievals out of 65,536 attempts.

### <b>AES128</b> 
For the three approaches used, the results for the first approach involving "special" plaintexts are:


| Number of Files | 256       | 1024       | 16384       |
|--------------- |-----------|------------|------------|
| Mean LC        | 32766.0   | 32766.0    | 32766.0    |
| Median LC      | 32122.328 | 31781.138  | 31689.144  |



The plots obtained were:

        {% include figure.liquid loading="eager" path="assets/img/blackbox/aes_impl1.jpg" title="Implementation-1 for AES128" class="img-fluid rounded z-depth-1" %}

For the second approach(Implementation 1b): 


| Number of Files | 256        | 1024        | 16384       |
|--------------- |------------|------------|------------|
| Mean LC        | 32766.0    | 32766.0    | 32766.0    |
| Median LC      | 31916.844  | 31659.744  | 31746.642  |




The plots obtained are similar to the first,

        {% include figure.liquid loading="eager" path="assets/img/blackbox/aes_impl1b.jpg" title="Implementation-1b for AES128" class="img-fluid rounded z-depth-1" %}


Keeping the number of rounds same as in Implementation 1, we analyze the linear complexity for the cases considered for k rounds, the Linear Complexity is observed to not have changed, more test could not be carried out with different plaintexts and implementations owing to time constraints.

One of the plots obtained is:

        {% include figure.liquid loading="eager" path="assets/img/blackbox/aes_impl3.jpg" title="Implementation-3 for AES128" class="img-fluid rounded z-depth-1" %}

The key findings can be summarized to be,
- For most cases, the linear complexity was approximately n/2n/2, where nn represents the sequence length. However, some cases exhibited even lower complexity.

- Despite calculating linear complexity, I was unable to extract any local inversions (keys) from any of the implementations.

- I observed a shift in the linear complexity distribution when comparing 16-bit and 32-bit key implementations. However, the overall structure of the plots remained consistent.

- In a few instances, the linear complexity was less than $\frac{max}{2}$, indicating potential areas that warrant further investigation.

- Finally, my analysis of the roundwise AES implementation revealed that changing the number of rounds did not significantly impact the linear complexity.

These results suggest that while the novel black box approach showed promise for analyzing AES128, it did not yield successful key retrievals as it had with RC4 in the previous case.


## <u><b>Conclusion</b></u>
The black box approach showed significantly different results when applied to RC4 versus AES128 and showed that RC4 is demonstrably vulnerable to the black box approach, confirming its status as a deprecated and weaker cipher, and AES128 showed strong resistance to the same attack methodology, supporting its continued use as a secure encryption standard.


## References
[^1]: V. Sule, “Local inversion of maps: A new attack on symmetric encryption, rsa and ecdlp,” 2022.

[^2]: Campbell, Simon. Non-Uniformities in the RC4 Stream Cipher.

[^3]: Victor, “Ntl: A library for doing number theory.”

[^4]: The OpenSSL Project.

[^5]: Wisniewska, Cecelia. “Ceceww/Aes.” GitHub, 19 Mar. 2022, github.com/ceceww/aes.

